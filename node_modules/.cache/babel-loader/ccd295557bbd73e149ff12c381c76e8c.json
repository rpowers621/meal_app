{"ast":null,"code":"import _objectSpread from\"/home/adithyazure/meal_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/adithyazure/meal_app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import React,{useState,useEffect}from\"react\";import getState from\"./flux.js\";// Don't change, here is where we initialize our context, by default it's just going to be null.\nimport{jsx as _jsx}from\"react/jsx-runtime\";export var Context=/*#__PURE__*/React.createContext(null);// This function injects the global store to any view/component where you want to use it, we will inject the context to layout.js, you can see it here:\n// https://github.com/4GeeksAcademy/react-hello-webapp/blob/master/src/js/layout.js#L35\nvar injectContext=function injectContext(PassedComponent){var StoreWrapper=function StoreWrapper(props){//this will be passed as the contenxt value\nvar _useState=useState(getState({getStore:function getStore(){return state.store;},getActions:function getActions(){return state.actions;},setStore:function setStore(updatedStore){return setState({store:Object.assign(state.store,updatedStore),actions:_objectSpread({},state.actions)});}})),_useState2=_slicedToArray(_useState,2),state=_useState2[0],setState=_useState2[1];useEffect(function(){/**\n\t\t\t * EDIT THIS!\n\t\t\t * This function is the equivalent to \"window.onLoad\", it only runs once on the entire application lifetime\n\t\t\t * you should do your ajax requests or fetch api requests here. Do not use setState() to save data in the\n\t\t\t * store, instead use actions, like this:\n\t\t\t **/state.actions.getMessage();// <---- calling this function from the flux.js actions\n},[]);// The initial value for the context is not null anymore, but the current state of this component,\n// the context will now have a getStore, getActions and setStore functions available, because they were declared\n// on the state of this component\nreturn/*#__PURE__*/_jsx(Context.Provider,{value:state,children:/*#__PURE__*/_jsx(PassedComponent,_objectSpread({},props))});};return StoreWrapper;};export default injectContext;","map":{"version":3,"sources":["/home/adithyazure/meal_app/src/Store/appContext.js"],"names":["React","useState","useEffect","getState","Context","createContext","injectContext","PassedComponent","StoreWrapper","props","getStore","state","store","getActions","actions","setStore","updatedStore","setState","Object","assign","getMessage"],"mappings":"iSAAA,MAAOA,CAAAA,KAAP,EAAgBC,QAAhB,CAA0BC,SAA1B,KAA2C,OAA3C,CACA,MAAOC,CAAAA,QAAP,KAAqB,WAArB,CAEA;2CACA,MAAO,IAAMC,CAAAA,OAAO,cAAGJ,KAAK,CAACK,aAAN,CAAoB,IAApB,CAAhB,CAEP;AACA;AACA,GAAMC,CAAAA,aAAa,CAAG,QAAhBA,CAAAA,aAAgB,CAAAC,eAAe,CAAI,CACxC,GAAMC,CAAAA,YAAY,CAAG,QAAfA,CAAAA,YAAe,CAAAC,KAAK,CAAI,CAC7B;AACA,cAA0BR,QAAQ,CACjCE,QAAQ,CAAC,CACRO,QAAQ,CAAE,0BAAMC,CAAAA,KAAK,CAACC,KAAZ,EADF,CAERC,UAAU,CAAE,4BAAMF,CAAAA,KAAK,CAACG,OAAZ,EAFJ,CAGRC,QAAQ,CAAE,kBAAAC,YAAY,QACrBC,CAAAA,QAAQ,CAAC,CACRL,KAAK,CAAEM,MAAM,CAACC,MAAP,CAAcR,KAAK,CAACC,KAApB,CAA2BI,YAA3B,CADC,CAERF,OAAO,kBAAOH,KAAK,CAACG,OAAb,CAFC,CAAD,CADa,EAHd,CAAD,CADyB,CAAlC,wCAAOH,KAAP,eAAcM,QAAd,eAYAf,SAAS,CAAC,UAAM,CACf;AACH;AACA;AACA;AACA;AACA,OACGS,KAAK,CAACG,OAAN,CAAcM,UAAd,GAA4B;AAC5B,CARQ,CAQN,EARM,CAAT,CAUA;AACA;AACA;AACA,mBACC,KAAC,OAAD,CAAS,QAAT,EAAkB,KAAK,CAAET,KAAzB,uBACC,KAAC,eAAD,kBAAqBF,KAArB,EADD,EADD,CAKA,CAhCD,CAiCA,MAAOD,CAAAA,YAAP,CACA,CAnCD,CAqCA,cAAeF,CAAAA,aAAf","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport getState from \"./flux.js\";\n\n// Don't change, here is where we initialize our context, by default it's just going to be null.\nexport const Context = React.createContext(null);\n\n// This function injects the global store to any view/component where you want to use it, we will inject the context to layout.js, you can see it here:\n// https://github.com/4GeeksAcademy/react-hello-webapp/blob/master/src/js/layout.js#L35\nconst injectContext = PassedComponent => {\n\tconst StoreWrapper = props => {\n\t\t//this will be passed as the contenxt value\n\t\tconst [state, setState] = useState(\n\t\t\tgetState({\n\t\t\t\tgetStore: () => state.store,\n\t\t\t\tgetActions: () => state.actions,\n\t\t\t\tsetStore: updatedStore =>\n\t\t\t\t\tsetState({\n\t\t\t\t\t\tstore: Object.assign(state.store, updatedStore),\n\t\t\t\t\t\tactions: { ...state.actions }\n\t\t\t\t\t})\n\t\t\t})\n\t\t);\n\n\t\tuseEffect(() => {\n\t\t\t/**\n\t\t\t * EDIT THIS!\n\t\t\t * This function is the equivalent to \"window.onLoad\", it only runs once on the entire application lifetime\n\t\t\t * you should do your ajax requests or fetch api requests here. Do not use setState() to save data in the\n\t\t\t * store, instead use actions, like this:\n\t\t\t **/\n\t\t\tstate.actions.getMessage(); // <---- calling this function from the flux.js actions\n\t\t}, []);\n\n\t\t// The initial value for the context is not null anymore, but the current state of this component,\n\t\t// the context will now have a getStore, getActions and setStore functions available, because they were declared\n\t\t// on the state of this component\n\t\treturn (\n\t\t\t<Context.Provider value={state}>\n\t\t\t\t<PassedComponent {...props} />\n\t\t\t</Context.Provider>\n\t\t);\n\t};\n\treturn StoreWrapper;\n};\n\nexport default injectContext;"]},"metadata":{},"sourceType":"module"}